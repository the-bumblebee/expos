// MODULE 0 - RESOURCE MANAGER

// Function number in R1 and PID in R2
alias funcNum R1;
alias currentPID R2;
alias returnValue R0;

// Checks if function number is 8 for Acquire Terminal
if (funcNum == ACQUIRE_TERMINAL) then
    call AcquireTerminal;
    return;
endif;

// Checks if function number is 9 for Release Terminal
if (funcNum == RELEASE_TERMINAL) then
    call ReleaseTerminal;
    return;
endif;

// Checks if function number is 9 for Acquire Disk
if (funcNum == ACQUIRE_DISK) then
    call AcquireDisk;
    return;
endif;

if (funcNum == ACQUIRE_SEMAPHORE) then
    call AcquireSemaphore;
    return;
endif;

if (funcNum == RELEASE_SEMAPHORE) then
    call ReleaseSemaphore;
    return;
endif;

// Return if wrong function number
return;


AcquireTerminal:
    // If terminal busy, call scheduler (Should be in a loop, consider a case with 3 programs)
    while ([TERMINAL_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + (currentPID * 16) + 4] = WAIT_TERMINAL;
        multipush(R0, R1, R2);
        call SCHEDULER;
        multipop(R0, R1, R2);
    endwhile;
    // This is executed only when terminal becomes free and the process acquire the terminal
    // STATUS is set to 1 and PID is set to the current PID in Terminal Status Table
    [TERMINAL_STATUS_TABLE] = 1;
    [TERMINAL_STATUS_TABLE + 1] = currentPID;
    return;

ReleaseTerminal:
    // Check if PID in R2 and System Status Table matches. If not return -1.
    if ([TERMINAL_STATUS_TABLE + 1] == currentPID) then
        // STATUS set to 0 Terminal Status Table
        [TERMINAL_STATUS_TABLE] = 0;
        // Setting STATUS of processes having WAIT_TERMINAL to READY
        alias newPID R3;
        alias newProcessTable R4;
        newPID = 1;
        newProcessTable = PROCESS_TABLE + (newPID * 16);
        while (newPID < 16) do
            if ([newProcessTable + 4] == WAIT_TERMINAL) then
                [newProcessTable + 4] = READY;
            endif;
            newPID = newPID + 1;
            newProcessTable = PROCESS_TABLE + (newPID * 16);
        endwhile;
        // Setting return vale as 0 to show success
        returnValue = 0;
        return;
    else
        returnValue = -1;
        return;
    endif;

// Argument: R2->PID
AcquireDisk:
    // While disk busy call scheduler
    while ([DISK_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + (currentPID * 16) + 4] = WAIT_DISK;
        multipush (R0, R1, R2);
        call SCHEDULER;
        multipop (R0, R1, R2);
    endwhile;
    // Setting STATUS and PID fields of the Disk Status Table
    [DISK_STATUS_TABLE] = 1;
    [DISK_STATUS_TABLE + 4] = currentPID;
    return;

AcquireSemaphore:
    alias index R3;
    index = 0;
    // Find free entry in Semaphore Table
    while ([SEMAPHORE_TABLE + 4 * index + 1] != 0 && index < MAX_SEM_COUNT) do
        index = index + 1;
    endwhile;
    // Return -1 if no free entry
    if (index == MAX_SEM_COUNT) then
        returnValue = -1;
        return;
    endif;
    // Increment PROCESS COUNT, LOCKING PID = -1
    [SEMAPHORE_TABLE + 4 * index + 1] = [SEMAPHORE_TABLE + 4 * index + 1] + 1;
    [SEMAPHORE_TABLE + 4 * index] = -1;
    // Return value -> index of the entry
    returnValue = index;
    return;

ReleaseSemaphore:
    alias SEMID R2;
    alias PID R3;
    alias semTableIndex R4;
    semTableIndex = [[PROCESS_TABLE + (PID * 16) + 11] * 512 + RESOURCE_TABLE_OFFSET + 2 *SEMID];
    if ([SEMAPHORE_TABLE + 4 * semTableIndex] == PID) then
        [SEMAPHORE_TABLE + 4 * semTableIndex] = -1;
        R4 = 1;
        while (R4 < 16) do
            if ([PROCESS_TABLE + (2 * R4) + 4] == WAIT_SEMAPHORE && [PROCESS_TABLE + (2 * R4) + 5] == semTableIndex) then
                [PROCESS_TABLE + (2 * R4) + 4] = READY;
            endif;
            R4 = R4 + 1;
        endwhile;
    endif;
    [SEMAPHORE_TABLE + 4 * semTableIndex + 1] = [SEMAPHORE_TABLE + 4 * semTableIndex + 1] - 1;
    return;